# 2.1 추상화

- 추상화란 어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업을 의미미

추상화는 사물들의 공통된 특징, 즉 추상적 특징을 파악해 인식의 대상으로 삼는 행위.  
추상화가 가능한 개체들은 개체가 소유한 특성의 이름으로 하나의 집합(class)를 이룸.  
추상화한다는 것ㅇ느 여러 개체들을 집합으로 파악한다는 것과 같음.  
추상적 특성은 집합을 구성하는 개체들을 일반화하는 것이므로 집합의 요소들에 보편적인 것임.

# 2.2 캡슐화

요구사항 변경에 대처하는 고전적인 설계 원리로 응집도(cohesion), 결합도(coupling)가 있음.  
높은 응집도와 낮은 결합도를 유지할 수 있도록 설계해야 요구사항 변경 시 유연하게 대처가 가능  
캡슐화는 특히 낮은 결합도를 유지할 수 있도록 해주는 객체지향 설계 원리로 정보 은닉(information hiding)을 통해 높은 응집도와 낮은 결합도를 갖도록 함

# 2.3 일반화 관계

## 2.3.1 일반화는 또 다른 캡슐화

객체지향 프로그래밍 관점에서는 상속 관계라고 함. 단순히 속성이나 기능의 재사용만 강조하는 것이 아님  
캡슐화의 개념은 한 클래스 안에 있는 속성 및 연산들의 캡슐화에 한정되지 않고 일반화 관계를 통해 클래스 자체를 캡슐화하는 것으로 확장됨  
이러한 서브 클래스 캡슐화는 외부 클라이언트가 개별적인 클래스들과 무관하게 프로그래밍을 할 수 있게 함

> 일반화 관게는 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종

## 2.3.2 일반화 관계와 위임

일반화 관계는 is a kind of 관계가 성립되어야 한다.

> 예를 들어 Stack을 ArrayList 클래스를 상속받아 구현한다면,  
> Stack is a kind of ArrayList라는 문장이 참이 되는지 확인해야 함  
> 예시의 경우는 거짓

그렇다면 어떤 클래스의 일부 기능만 재사용하고 싶은 경우 어떻게 하는 것이 좋을까?

이때 위임(delegation)을 사용

위임으로 일반화를 대신하는 과정

1. 자식 클래스에 부모 클래스의 인스턴스를 참조하는 속성을 만들고 이 속성필드를 this로 초기화
2. 서브 클래스에 정의된 각 메서드에 1번에서 마든 위임 속성 필드를 참조하도록 변경
3. 서브 클래스에서 일반화 관계 선언을 제거, 위임 속성 필드에 슈퍼 클래스의 객체를 생성해 대입
4. 서크 클래스에서 사용된 슈퍼클래스의 메서드에도 위임 메소드를 추가

## 2.3.3 집합론 관점으로 본 일반화 관계

제약 {disjoint}는 자식 클래스 객체가 동시에 두 클래스에 속할 수 없다는 의미  
제약 {complete}는 자식 클래스의 객체에 해당하는 부모 클래스의 객체와 부모 클래스의 객체에 해당하는 자식 클래스의 객체가 하나만 존재한다는 의미

예시로 어떤 웹 쇼핑몰에서 구매액을 기준으로 회원을 VIP, 일반으로 분류하고 쇼핑몰과 동일한 지역에서 사는 회원인지에 따라 분류한다고 하자

그러면 회원을 구매액과 지역 주민이라는 변별자에 따라 분류 해야함  
그러나 이때 한 인스턴스가 동시에 여러 클래스에 속할수 있고 이를 다중 분류라고 함  
일반적으로 변별자에 따른 일반화 관계가 완전하게 독립적인 경우 별다른 문제가 없지만 요구사항의 변경에 따라 관계가 독립적이지 않을 수 있음

따라서 아래와 같이 클래스를 나눌 수 있음  
Member

- VIP Member
  - VIP-Local
  - VIP-Non Local
- Ord Member
  - Ord-Local
  - Ord-Non Local

# 2.4 다형성

다형성은 서로 다른 클래스의 객체가 같은 메시지를 받았을 때, 각자의 방식으로 동작하는 능력으로 다형성과 일반화 관계는 코드를 간결하게 할 뿐 아니라 유연하게 대처할 수 있게 함

# 2.5 피터 코드의 상속 규칙

Peter Coad는 상속의 오용을 막기 위해 아래의 5가지 규칙중 하나라도 만족하지 않는다면 상속을 사용해서는 안된다는 규칙을 만듬

1. 자식 클래스와 부모 클래스 사이는 역할 수행 관계(is role played by)가 아니어야 한다.
2. 한 클래스의 인스턴스는 다른 서브 클래스의 객체로 변환할 필요가 절대 없어야 함
3. 자식 클래스가 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 함
4. 자식 클래스가 단지 일부 기능을 재사용할 목적으로 유틸리티 역할을 수행하는 클래스를 상속하지 않아야 함
   자식 크랠스가 역할, 트랜잭션, 디바이스 등을 특수화 해야함
